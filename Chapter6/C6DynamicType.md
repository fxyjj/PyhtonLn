# Dynamic Type
在Python中，类型是在运行时自动决定的，不是通过代码声名的。

## 1. 变量

* 变量在代码第一次给他赋值时就创建了他，之后的赋值会改变变量的值。
* 变量原本是通用的，只是在一个特定的时间引用了一个特定的对象。
* eg. 在运行代码
    `a = 3`

时， python会执行三步操作：
   1. 创建一个对象3
   2. 创建一个变量a，若a已经存在，则改变a连接为对象3
   3. 将变量a 与对象3连接。
**创建 a = 3 后，在计算机内部实际上a为对象3的一个的一个引用，是指向对象 3 内存空间的一个指针**

* 变量与对象保存在内存中的不同部分，并通过连接（上述的赋值操作，也成为**引用，通过指针来实现**）相关联。变量总是与对象相关联，而不会连接到其他变量上。对象可以连接到更大的对象上（OOP）

* *变量*包含指向对象的连接，*对象（对象实例）*是一个块被分配的物理内存，并有足够的空间来存储所表示的值； *引用*则是变量指向对象的一个指针。 

## 2. 类型属于对象

* 变量总是在被引用后自动解引用，即python不允许对引用本身进行操作，且变量没有类型，**他不受任何与他关联的对象的类型信息的约束。**
>> 在C语言中, 指针会有类型，也能够被允许修改他的值，这会导致很多麻烦，诸如指向非法地址，指向错误的类型等。

* 对象记录了其类型（type designator，一个指向对象的指针，如对象实例3中的type designator 是指向的是int对象的指针）， 变量就不用再记录了。

## 3. 对象

### 3.1 对象的组成

* Type Designator : 一个指向对象类型的指针，记录了对象实例的类型。
* Reference Counter: 决定对象何时被回收。

### 3.2 垃圾收集。

* 每当一个变量被赋值时，如果原来的对象没有被其他变量所引用，该对象的内存空间就会被回收。

>>python 内部是通过上述的Reference Counter 来实现垃圾回收的。给计数器记录了指向给对象的引用的条目（同一时间），而一旦该计数器被设置为0，该对象会被立即清除。

**垃圾收集对循环引用的处理**

。。。

