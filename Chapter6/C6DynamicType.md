# Dynamic Type
在Python中，类型是在运行时自动决定的，不是通过代码声名的。

## 1. 变量

* 变量在代码第一次给他赋值时就创建了他，之后的赋值会改变变量的值。
* 变量原本是通用的，只是在一个特定的时间引用了一个特定的对象。
* eg. 在运行代码
    `a = 3`

时， python会执行三步操作：
   1. 创建一个对象3
   2. 创建一个变量a，若a已经存在，则改变a连接为对象3
   3. 将变量a 与对象3连接。
**创建 a = 3 后，在计算机内部实际上a为对象3的一个的一个引用，是指向对象 3 内存空间的一个指针**

* 变量与对象保存在内存中的不同部分，并通过连接（上述的赋值操作，也成为**引用，通过指针来实现**）相关联。变量总是与对象相关联，而不会连接到其他变量上。对象可以连接到更大的对象上（OOP）

* *变量*包含指向对象的连接，*对象（对象实例）*是一个块被分配的物理内存，并有足够的空间来存储所表示的值； *引用*则是变量指向对象的一个指针。 

## 2. 类型属于对象

* 变量总是在被引用后自动解引用，即python不允许对引用本身进行操作，且变量没有类型，**他不受任何与他关联的对象的类型信息的约束。**
>> 在C语言中, 指针会有类型，也能够被允许修改他的值，这会导致很多麻烦，诸如指向非法地址，指向错误的类型等。

* 对象记录了其类型（type designator，一个指向对象的指针，如对象实例3中的type designator 是指向的是int对象的指针）， 变量就不用再记录了。

## 3. 对象

### 3.1 对象的组成

* Type Designator : 一个指向对象类型的指针，记录了对象实例的类型。
* Reference Counter: 决定对象何时被回收。

### 3.2 垃圾收集。

* 每当一个变量被赋值时，如果原来的对象没有被其他变量所引用，该对象的内存空间就会被回收。

>>python 内部是通过上述的Reference Counter 来实现垃圾回收的。给计数器记录了指向给对象的引用的条目（同一时间），而一旦该计数器被设置为0，该对象会被立即清除。

**垃圾收集对循环引用的处理**

。。。

## 3. 共享引用

```>> a = 3
>> b = a
```
运行该命令以后，变量a与b都指向了对象实例3，即他们都成了对象3的引用

```>> a = 3
>> b = a 
>> a = 'spam'
>>a
spam
>>b
3
```
or
```>> a = 3
>> b = a
>> b = 'spam'
>> a
3
>> b
spam
```
尽管变量a，b指向相同的对象，但是在a(或者b)在被修改（重新赋值）后，不会影响b(a)的值。

### 3.1 原位置修改

* 上述的对象3是整数类型，向之前谈到过的，整数在被创建过后不能再被修改，所以不能在原位置修改它，因此不会发生改变a使得b也发生变化的情况。

* 但是对于那些可变的对象来说，我们可以原位置修改它们，这要求我们在使用共享引用时要特别小心。

```
>>> l1 = [2,3,4]
>>> l2 = l1

>>> l1
[2, 3, 4]
>>> l2
[2, 3, 4]

>>> l2=24
>>> l1
[2, 3, 4]
>>> l2
24

>>> l2=l1
>>> l1[0]=24
>>> l1
[24, 3, 4]
>>> l2
[24, 3, 4]

>>> import copy

>>> l2=l1[:]
>>> l1
[24, 3, 4]
>>> l2
[24, 3, 4]

>>> l1[0]=2
>>> l1
[2, 3, 4]
>>> l2
[24, 3, 4]

# ways of copying a list
>>> l1=[2,3,4]
>>> l2=l1
>>> l2=l1[:]
>>> l2 = list(l1)
>>> l2=l1.copy()
>>> l2=copy.copy(l1) # shallow copy of l1, 对于复制单个简单对象，对于嵌套对像只引用
>>> l2=copy.deepcopy(l1) # deep copy of l1, 复制所有对象。
```

*对于list这类可变对象来说，共享引用的两个变量会会随着list对象的改变而一起改变，如果不想这种情况发生，我们需要给两个变量定义不同的引用，即复制对象，使他们指向不同内存空间的对象，而这两个对象的值是相等的。*

### 3.2 相等

* 对于垃圾回收机制，如果一个对象的referencecount 被设置成0 后，它会被立即清除，但是由于小的整数与字符串的高频率使用，Python会缓存这部分对象，使得他们可以被重复利用。对于这类被缓存的对象，python不会立即回收他们，但是这类对象并不会影响代码的编写

* python中有两种测试等价的方法： **'==' 操作符**和**'is' 运算符**
```
>>> L = [2,3,4]
>>> M = L
>>> M == L
True
>>> M is L
True
```

* '==' 用于测试被引用的两个对象是否有相同的值
* 'is' 用于检测对象的同一性。如果两个变量名精确的指向同一个对象，那么他会返回True表明这两个对象是同一的。实际上，它比较了两个变量的引用指针，所以也是一种**检验共享引用的方法**

```
>>> L=[1,2,3]
>>> M=[1,2,3]
>>> L == M
True
>>> L is M
False
```

* 对于被缓存的对象实例，python不会立马清除他们，所以这里42在被创建两次引用后其实 L 和 M 都指向一个对象实例42，因为他被缓存了。
```
>>> L = 42
>>> M = 42
>>> L == M
True
>>> L is M
True
```






